# This is automatically generated code, do not edit.
# Generated by Polygen %% version %%
# %% datetime %%

from __future__ import annotations

from functools import wraps

from polygen.reader import Reader
from polygen.node import (
    Grammar,
    Rule,
    MetaRef,
    MetaRule,
    Expr,
    Alt,
    NamedItem,
    Id,
    String,
    Char,
    AnyChar,
    Class,
    Range,
    ZeroOrOne,
    ZeroOrMore,
    OneOrMore,
    Repetition,
    And,
    Not
)

__all__ = ['Parser']


class Success:
    """Parsing result wrapper."""

    def __init__(self, value=None):
        self.value = value

    def __repr__(self):
        return f'Success({self.value})'

    def __str__(self):
        return repr(self)


def _memoize(fn):

    @wraps(fn)
    def wrapper(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            result = fn(self, *args)
            endpos = self._mark()
            self._memos[key] = result, endpos
        else:
            result, endpos = memo
            self._reset(endpos)

        if result is not None:
            if type(result) is not Success:
                return Success(result)
        return result

    return wrapper


def _memoize_lr(fn):

    @wraps(fn)
    def wrapper_lr(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            self._memos[key] = lastres, lastpos = None, pos

            while True:
                self._reset(lastpos)
                result = fn(self, *args)
                endpos = self._mark()
                if endpos <= lastpos:
                    break

                self._memos[key] = lastres, lastpos = result, endpos
                new_key = (fn, args, endpos)
                self._memos[new_key] = lastres, lastpos

            result = lastres
            self._reset(lastpos)

        else:
            result, endpos = memo
            self._reset(endpos)

        if result is not None:
            if type(result) is not Success:
                return Success(result)
        return result

    return wrapper_lr


class Parser:

    def __init__(self, reader: Reader, actions=None):
        self._memos = {}

        self._heads = {}
        self._lrstack = []

        self._reader = reader
        self._chars: list[str] = []
        self._pos = 0

    @_memoize
    def _expectc(self, char: str | None = None) -> Success | None:
        if c := self._peek_char():
            if char is None or c == char:
                self._pos += 1
                return Success(c)
        return None

    @_memoize
    def _expects(self, string: str) -> Success | None:
        pos = self._mark()
        for c in string:
            if c != self._peek_char():
                self._reset(pos)
                return None
            self._pos += 1
        return Success(string)

    def _lookahead(self, positive, fn, *args) -> Success | None:
        pos = self._mark()
        ok = fn(*args) is not None
        self._reset(pos)
        if ok == positive:
            return Success()
        return None

    def _loop(self, nonempty, fn, *args) -> Success | None:
        pos = lastpos = self._mark()
        nodes = []
        while (node := fn(*args)) is not None and self._mark() > lastpos:
            # Unwrap nodes, removing empty wrappers
            if node.value is not None:
                nodes.append(node.value)
            lastpos = self._mark()
        if len(nodes) >= nonempty:
            return Success(nodes)
        self._reset(pos)
        return None

    def _rep(self, beg, end, fn, *args) -> Success | None:
        end = beg if end is None else end
        pos = lastpos = self._mark()
        count = 0
        nodes = []
        while (node := fn(*args)) is not None and self._mark() > lastpos:
            nodes.append(node)
            lastpos = self._mark()
            count += 1
        if count >= beg and count <= end:
            # Unwrap nodes, removing empty wrappers
            nodes = tuple(n.value for n in nodes if n.value is not None)
            return Success(nodes)
        self._reset(pos)
        return None

    def _ranges(self, *ranges):
        char = self._peek_char()
        if char is None:
            return None
        for beg, end in ranges:
            if char >= beg and char <= end:
                return Success(self._get_char())

    def _maybe(self, fn, *args):
        result = fn(*args)
        return Success(result.value if result is not None else result)

    def _get_char(self) -> str | None:
        char = self._peek_char()
        self._pos += 1
        return char

    def _peek_char(self) -> str | None:
        if self._pos == len(self._chars):
            self._chars.append(next(self._reader, None))
        return self._chars[self._pos]

    def _mark(self) -> int:
        return self._pos

    def _reset(self, pos: int):
        self._pos = pos

    def parse(self) -> Success:
        return self._%% entry %%()

    %% body %%

if __name__ == '__main__':
    from argparse import ArgumentParser, FileType
    import sys

    argparser = ArgumentParser()
    argparser.add_argument('input_file', nargs='?',
                           type=FileType('r', encoding='UTF-8'),
                           default=sys.stdin)

    ns = argparser.parse_args()

    parser = Parser(ns.input_file)
    result = parser.parse()

    if result is not None:
        print(result)

    print("Parsing successful" if result else "Parsing failure")
    exit(not result)  # Unix-style: 0 is success
