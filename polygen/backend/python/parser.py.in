# This is automatically generated code, do not edit.
# Generated by Polygen %% version %%

from __future__ import annotations

from functools import wraps
from typing import Optional, Union, Any, List

from polygen.reader import Reader
from polygen.node import (
    Grammar,
    Rule,
    MetaRef,
    MetaRule,
    Expr,
    Alt,
    NamedItem,
    Id,
    String,
    Char,
    AnyChar,
    Class,
    Range,
    ZeroOrOne,
    ZeroOrMore,
    OneOrMore,
    Repetition,
    And,
    Not
)

__all__ = ['Parser']


class _MemoEntry:
    def __init__(self, value: Union[str, Any], pos: int):
        self.value = value
        self.pos = pos

    def __repr__(self):
        return f"MemoEntry({self.value}, {self.pos})"

    def __str__(self):
        return repr(self)


def _memoize(fn):

    @wraps(fn)
    def wrapper(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            self._memos[key] = memo = _MemoEntry(fn(self, *args), self._mark())
        else:
            self._reset(memo.pos)
        return memo.value

    return wrapper


def _memoize_lr(fn):

    @wraps(fn)
    def wrapper_lr(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            self._memos[key] = memo = _MemoEntry(None, pos)

            while True:
                self._reset(memo.pos)
                result = fn(self, *args)
                endpos = self._mark()
                if endpos <= memo.pos:
                    break

                memo.value, memo.pos = result, endpos
                new_key = (fn, args, endpos)
                self._memos[new_key] = memo

            result = memo.value
            self._reset(memo.pos)

        else:
            result = memo.value
            self._reset(memo.pos)

        return result

    return wrapper_lr


class Parser:

    def __init__(self, reader: Reader, actions=None):
        self._memos = {}

        self._heads = {}
        self._lrstack = []

        self._reader = reader
        self._chars: List[str] = []
        self._pos = 0

    @_memoize
    def _expectc(self, char: Optional[str] = None) -> Optional[str]:
        if c := self._peek_char():
            if char is None or c == char:
                self._pos += 1
                return c
        return None

    @_memoize
    def _expects(self, string: str) -> Optional[str]:
        pos = self._mark()
        for c in string:
            if c != self._peek_char():
                self._reset(pos)
                return None
            self._pos += 1
        return string

    def _lookahead(self, positive, fn, *args) -> Optional[list]:
        pos = self._mark()
        ok = fn(*args) is not None
        self._reset(pos)
        if ok == positive:
            return []
        return None

    def _loop(self, nonempty, fn, *args) -> Optional[List[str]]:
        pos = lastpos = self._mark()
        nodes = []
        while (node := fn(*args)) is not None and self._mark() > lastpos:
            nodes.append(node)
            lastpos = self._mark()
        if len(nodes) >= nonempty:
            return nodes
        self._reset(pos)
        return None

    def _rep(self, beg, end, fn, *args) -> Optional[List[str]]:
        end = beg if end is None else end
        pos = lastpos = self._mark()
        count = 0
        nodes = []
        while (node := fn(*args)) is not None and self._mark() > lastpos:
            nodes.append(node)
            lastpos = self._mark()
            count += 1
        if count >= beg and count <= end:
            return nodes
        self._reset(pos)
        return None

    def _ranges(self, *ranges) -> Optional[str]:
        char = self._peek_char()
        if char is None:
            return None
        for beg, end in ranges:
            if char >= beg and char <= end:
                self._pos += 1
                return char

    def _maybe(self, fn, *args) -> Union[list, str, Any]:
        result = fn(*args)
        return result if result is not None else []

    def _get_char(self) -> Optional[str]:
        char = self._peek_char()
        self._pos += 1
        return char

    def _peek_char(self) -> Optional[str]:
        if self._pos == len(self._chars):
            self._chars.append(next(self._reader, None))
        return self._chars[self._pos]

    def _mark(self) -> int:
        return self._pos

    def _reset(self, pos: int):
        self._pos = pos

    def parse(self) -> Any:
        return self._%% entry %%()

    %% body %%

if __name__ == '__main__':
    from argparse import ArgumentParser, FileType
    import sys

    argparser = ArgumentParser()
    argparser.add_argument('input_file', nargs='?',
                           type=FileType('r', encoding='UTF-8'),
                           default=sys.stdin)

    ns = argparser.parse_args()

    parser = Parser(ns.input_file)
    result = parser.parse()

    if result is not None:
        print(result)

    print("Parsing successful" if result is not None else "Parsing failure")
    exit(result is None)  # Unix-style: 0 is success
