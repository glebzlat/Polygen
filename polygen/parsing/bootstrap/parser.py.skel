# This is automatically generated code, do not edit.
# Generated by Polygen %% version %%
# %% datetime %%


from __future__ import annotations

from typing import Optional
from functools import wraps

from polygen.parsing.reader import Reader
from polygen.grammar.node import (
    Node,
    Grammar,
    Expression,
    Rule,
    MetaRef,
    MetaRule,
    Identifier,
    Range,
    Alt,
    Part,
    AnyChar,
    String,
    Class,
    Not,
    And,
    ZeroOrOne,
    ZeroOrMore,
    OneOrMore,
    Repetition,
    Char
)


def isnode(obj):
    return isinstance(obj, Node)


def memoize(fn):

    @wraps(fn)
    def wrapper(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            result = fn(self, *args)
            endpos = self._mark()
            self._memos[key] = result, endpos
        else:
            result, endpos = memo
            self._reset(endpos)
        return result

    return wrapper


def memoize_lr(fn):

    @wraps(fn)
    def wrapper(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)

        # if not growing a seed parse, return memo
        lr = self._leftrec
        if lr is not None:

            # do not evaluate rule that is not involved in the leftrec
            if fn not in {lr.head} | lr.involved_set:
                memo = None, pos

            # involved rules are evaluated only once
            # during a seed-growing iteration
            elif fn in lr.eval_set:
                lr.eval_set.remove(fn)
                result = fn(self, *args)
                endpos = self._mark()
                memo = result, endpos

        if memo is None:
            # prime a cache with a failure
            self._memos[key] = lastres, lastpos = None, pos

            # loop until no longer parse is obtained
            while True:
                self._reset(pos)
                result = fn(self, *args)
                endpos = self._mark()
                if endpos <= lastpos:
                    break
                self._memos[key] = lastres, lastpos = result, endpos

            result = lastres
            self._reset(lastpos)

        else:
            result, endpos = memo
            self._reset(endpos)

        return result

    return wrapper


class LR:
    def __init__(self, head, involved_set):
        self.head = head.__wrapped__
        self.involved_set = set(fn.__wrapped__ for fn in involved_set)
        self.eval_set = set(fn.__wrapped__ for fn in involved_set)

    def __repr__(self):
        return f"LR(head={self.head}, involved_set={self.involved_set})"

    def __str__(self):
        return self.__repr__()


class Parser:
    def __init__(self, stream, actions=None):
        self._memos = {}
        self._leftrec = None
        self.reader = Reader(stream)
        self.chars: list[str] = []
        self.actions = actions
        self.pos = 0

    @memoize
    def _expectc(self, char: str | None = None) -> Optional[str]:
        if c := self._peek_char():
            if char is not None and c != char:
                return None
            self.pos += 1
            return c
        return None

    @memoize
    def _expects(self, string: str) -> Optional[str]:
        pos = self._mark()
        for c in string:
            if c != self._peek_char():
                self._reset(pos)
                return None
            self.pos += 1
        return string

    def _lookahead(self, positive, fn, *args):
        pos = self._mark()
        ok = fn(*args) is not None
        self._reset(pos)
        return ok == positive

    def _loop(self, nonempty, fn, *args):
        pos = self._mark()
        nodes = []
        while (node := fn(*args)) is not None:
            nodes.append(node)
        if len(nodes) >= nonempty:
            return nodes
        self._reset(pos)
        return None

    def _maybe(self, fn, *args):
        if (result := fn(*args)) is not None:
            return result
        return True

    def _get_char(self) -> str:
        char = self._peek_char()
        self.pos += 1
        return char

    def _peek_char(self) -> str:
        if self.pos == len(self.chars):
            self.chars.append(next(self.reader, None))
        return self.chars[self.pos]

    def _mark(self) -> int:
        return self.pos

    def _reset(self, pos: int):
        self.pos = pos

    def _action(self, rulename, *args, **kwargs):
        if self.actions is not None:
            fn = getattr(self.actions, rulename, None)
            if fn:
                return fn(**kwargs)
        return args

    def parse(self):
        return self._%% entry %%()

    %% body %%

if __name__ == '__main__':
    from argparse import ArgumentParser, FileType
    import sys

    argparser = ArgumentParser()
    argparser.add_argument('input_file', type=FileType('r', encoding='UTF-8'),
                           default=sys.stdin)

    ns = argparser.parse_args()

    parser = Parser(ns.input_file)
    result = parser.parse()

    for r in result:
        print(repr(r), end='\n\n')

    print("Parsing successful" if result else "Parsing failure")
    exit(not result)  # Unix-style: 0 is success
