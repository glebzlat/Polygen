# This is automatically generated code, do not edit.
# Generated by Polygen %% version %%
# %% datetime %%


from __future__ import annotations

from typing import Optional

from polygen.parsing.reader import Reader
from polygen.grammar.node import (
    Node,
    Grammar,
    Expression,
    Rule,
    MetaRef,
    MetaRule,
    Identifier,
    Range,
    Alt,
    Part,
    AnyChar,
    String,
    Class,
    Not,
    And,
    ZeroOrOne,
    ZeroOrMore,
    OneOrMore,
    Repetition,
    Char
)


def isnode(obj):
    return isinstance(obj, Node)


def memoize(fn):
    def wrapper(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            result = fn(self, *args)
            endpos = self._mark()
            self._memos[key] = result, endpos
        else:
            result, endpos = memo
            self._reset(endpos)
        return result

    return wrapper


class Parser:
    def __init__(self, stream, actions=None):
        self._memos = {}
        self.reader = Reader(stream)
        self.chars: list[str] = []
        self.actions = actions
        self.pos = 0

    @memoize
    def _expectc(self, char: str | None = None) -> Optional[str]:
        if c := self._peek_char():
            if char is not None and c != char:
                return None
            self.pos += 1
            return c
        return None

    @memoize
    def _expects(self, string: str) -> Optional[str]:
        pos = self._mark()
        for c in string:
            if c != self._peek_char():
                self._reset(pos)
                return None
            self.pos += 1
        return string

    def _lookahead(self, positive, fn, *args):
        pos = self._mark()
        ok = fn(*args) is not None
        self._reset(pos)
        return ok == positive

    def _loop(self, nonempty, fn, *args):
        pos = self._mark()
        nodes = []
        while (node := fn(*args)) is not None:
            nodes.append(node)
        if len(nodes) >= nonempty:
            return nodes
        self._reset(pos)
        return None

    def _maybe(self, fn, *args):
        if (result := fn(*args)) is not None:
            return result
        return True

    def _get_char(self) -> str:
        char = self._peek_char()
        self.pos += 1
        return char

    def _peek_char(self) -> str:
        if self.pos == len(self.chars):
            self.chars.append(next(self.reader, None))
        return self.chars[self.pos]

    def _mark(self) -> int:
        return self.pos

    def _reset(self, pos: int):
        self.pos = pos

    def _action(self, rulename, *args, **kwargs):
        if self.actions is not None:
            fn = getattr(self.actions, rulename, None)
            if fn:
                return fn(**kwargs)
        return args

    def parse(self):
        return self._%% entry %%()

    %% body %%

if __name__ == '__main__':
    from argparse import ArgumentParser, FileType
    import sys

    argparser = ArgumentParser()
    argparser.add_argument('input_file', type=FileType('r', encoding='UTF-8'),
                           default=sys.stdin)

    ns = argparser.parse_args()

    parser = Parser(ns.input_file)
    result = parser.parse()

    for r in result:
        print(repr(r), end='\n\n')

    print("Parsing successful" if result else "Parsing failure")
    exit(not result)  # Unix-style: 0 is success
