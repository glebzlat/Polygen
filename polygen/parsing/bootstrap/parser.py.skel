# This is automatically generated code, do not edit.
# Generated by Polygen %% version %%
# %% datetime %%

from __future__ import annotations

from typing import Optional
from functools import wraps

from polygen.parsing.reader import Reader
from polygen.grammar.node import (
    Node,
    Grammar,
    Expression,
    Rule,
    MetaRef,
    MetaRule,
    Identifier,
    Range,
    Alt,
    Part,
    AnyChar,
    String,
    Class,
    Not,
    And,
    ZeroOrOne,
    ZeroOrMore,
    OneOrMore,
    Repetition,
    Char
)

__all__ = ['Parser']


def isnode(obj):
    return isinstance(obj, Node)


def _memoize(fn):

    @wraps(fn)
    def wrapper(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            result = fn(self, *args)
            endpos = self._mark()
            self._memos[key] = result, endpos
        else:
            result, endpos = memo
            self._reset(endpos)
        return result

    return wrapper


class _LR:
    def __init__(self, seed, rule, head):
        self.seed = seed
        self.rule = rule
        self.head = head

    def __repr__(self):
        return f'_LR(seed={self.seed}, rule={self.rule}, head={self.head})'

    def __str__(self):
        return repr(self)


class _Head:
    def __init__(self, rule, involved_set, eval_set):
        self.rule = rule
        self.involved_set = involved_set
        self.eval_set = eval_set

    def __repr__(self):
        return f'_Head({self.rule}, {self.involved_set}, {self.eval_set})'

    def __str__(self):
        return repr(self)


def _memoize_lr(fn):
    # The algorithm is taken from "Packrat parsers can support left recursion"
    # https://dl.acm.org/doi/10.1145/1328408.1328424

    rule = fn.__name__

    def recall(self, args):
        pos = self._mark()
        key = (fn, args, pos)
        m = self._memos.get(key)
        head = self._heads.get(pos)

        # If not growing a seed parse, just return what is stored
        # in the memo table
        if head is None:
            return m

        # Do not evaluate any rule that is not involved in This
        # left recursion
        if m is None and rule not in head.involved_set | {head.rule}:
            return None, pos

        # Allow involved rules to be evaluated, but only once,
        # during a seed-growing iteration
        if rule in head.eval_set:
            head.eval_set.remove(rule)
            result = fn(self, *args)
            endpos = self._mark()
            m = result, endpos

        return m

    @wraps(fn)
    def wrapper_lr(self, *args):
        m = recall(self, args)
        if m is None:
            pos = self._mark()
            key = (fn, args, pos)

            # Create a new LR and push in onto
            # the rule invocation stack
            lr = _LR(None, rule, None)
            self._lrstack.append(lr)

            # Memoize lr, then evaluate rule
            self._memos[key] = lr, pos
            result = fn(self, *args)
            self._lrstack.pop()
            endpos = self._mark()
            self._memos[key] = lr, endpos

            if lr.head is not None:
                lr.seed = result
                return lr_answer(self, args, key, pos)
            else:
                self._memos[key] = result, endpos
                return result

        else:
            result, pos = m
            self._reset(pos)
            if type(result) is _LR:
                setup_lr(self, result)
                return result.seed
            else:
                return result

    def setup_lr(self, lr):
        if lr.head is None:
            lr.head = _Head(rule, set(), set())
        for i in reversed(self._lrstack):
            if i.head == lr.head:
                break
            i.head = lr.head
            lr.head.involved_set.add(i.rule)

    def lr_answer(self, args, key, pos):
        result, lastpos = self._memos[key]
        if result.head.rule != rule:
            return result.seed
        else:
            self._memos[key] = result.seed, lastpos
            if result.seed is None:
                return None
            return grow_lr(self, args, key, result.head, pos)

    def grow_lr(self, args, key, head, pos):
        result, _ = self._memos[key]
        self._heads[pos] = head

        self._memos[key] = lastres, lastpos = result, pos
        while True:
            self._reset(pos)
            head.eval_set = head.involved_set.copy()
            result = fn(self, *args)
            endpos = self._mark()
            if result is None or endpos <= lastpos:
                break
            self._memos[key] = lastres, lastpos = result, endpos

        result = lastres
        self._reset(lastpos)
        self._heads.pop(pos)

        return result

    return wrapper_lr


class Parser:

    def __init__(self, stream, actions=None):
        self._memos = {}

        self._heads = {}
        self._lrstack = []

        self._reader = Reader(stream)
        self._chars: list[str] = []
        self._pos = 0

    @_memoize
    def _expectc(self, char: str | None = None) -> Optional[str]:
        if c := self._peek_char():
            if char is not None and c != char:
                return None
            self._pos += 1
            return c
        return None

    @_memoize
    def _expects(self, string: str) -> Optional[str]:
        pos = self._mark()
        for c in string:
            if c != self._peek_char():
                self._reset(pos)
                return None
            self._pos += 1
        return string

    def _lookahead(self, positive, fn, *args):
        pos = self._mark()
        ok = fn(*args) is not None
        self._reset(pos)
        return ok == positive

    def _loop(self, nonempty, fn, *args) -> Optional[list]:
        pos = lastpos = self._mark()
        nodes = []
        while (node := fn(*args)) is not None and self._mark() > lastpos:
            nodes.append(node)
            lastpos = self._mark()
        if len(nodes) >= nonempty:
            return nodes
        self._reset(pos)
        return None

    def _maybe(self, fn, *args):
        if (result := fn(*args)) is not None:
            return result
        return True

    def _get_char(self) -> str:
        char = self._peek_char()
        self._pos += 1
        return char

    def _peek_char(self) -> str:
        if self._pos == len(self._chars):
            self._chars.append(next(self._reader, None))
        return self._chars[self._pos]

    def _mark(self) -> int:
        return self._pos

    def _reset(self, pos: int):
        self._pos = pos

    def parse(self):
        return self._%% entry %%()

    %% body %%

if __name__ == '__main__':
    from argparse import ArgumentParser, FileType
    import sys

    argparser = ArgumentParser()
    argparser.add_argument('input_file', nargs='?',
                           type=FileType('r', encoding='UTF-8'),
                           default=sys.stdin)

    ns = argparser.parse_args()

    parser = Parser(ns.input_file)
    result = parser.parse()

    if result is not None:
        print(result)

    print("Parsing successful" if result else "Parsing failure")
    exit(not result)  # Unix-style: 0 is success
