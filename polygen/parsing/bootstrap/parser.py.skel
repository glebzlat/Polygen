# This is automatically generated code, do not edit.
# Generated by Polygen %% version %%
# %% datetime %%


from __future__ import annotations

from typing import Optional
from functools import wraps

from polygen.parsing.reader import Reader
from polygen.grammar.node import (
    Node,
    Grammar,
    Expression,
    Rule,
    MetaRef,
    MetaRule,
    Identifier,
    Range,
    Alt,
    Part,
    AnyChar,
    String,
    Class,
    Not,
    And,
    ZeroOrOne,
    ZeroOrMore,
    OneOrMore,
    Repetition,
    Char
)


def isnode(obj):
    return isinstance(obj, Node)


def memoize(fn):

    @wraps(fn)
    def wrapper(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)
        if memo is None:
            result = fn(self, *args)
            endpos = self._mark()
            self._memos[key] = result, endpos
        else:
            result, endpos = memo
            self._reset(endpos)
        return result

    return wrapper


def memoize_lr(fn):

    @wraps(fn)
    def wrapper_lr(self, *args):
        pos = self._mark()
        key = (fn, args, pos)
        memo = self._memos.get(key)

        # if not growing a seed parse, return memo
        lr = self._leftrec
        if lr is not None:
            fn_name = fn.__name__

            # do not evaluate rule that is not involved in the leftrec
            if fn_name not in lr.involved_set:
                memo = None, pos

            # involved rules are evaluated only once
            # during a seed-growing iteration
            elif fn_name in lr.eval_set:
                lr.eval_set.remove(fn_name)
                result = fn(self, *args)
                endpos = self._mark()
                memo = result, endpos

        if memo is None:
            # prime a cache with a failure
            self._memos[key] = lastres, lastpos = None, pos

            # loop until no longer parse is obtained
            while True:
                self._reset(pos)
                result = fn(self, *args)
                endpos = self._mark()
                if endpos <= lastpos:
                    break
                self._memos[key] = lastres, lastpos = result, endpos

            result = lastres
            self._reset(lastpos)

        else:
            result, endpos = memo
            self._reset(endpos)

        return result

    return wrapper_lr


class Parser:

    class _LR:
        def __init__(self, involved_set):
            self.involved_set = involved_set
            self.eval_set = self.involved_set.copy()

        def __repr__(self):
            parts = (f'{name}={value}' for name, value in vars(self).items())
            parens = ', '.join(parts)
            return f"_LR({parens})"

        def __str__(self):
            return self.__repr__()

    def __init__(self, stream, actions=None):
        self._memos = {}
        self._leftrec = None
        self.reader = Reader(stream)
        self.chars: list[str] = []
        self.actions = actions
        self.pos = 0

    @memoize
    def _expectc(self, char: str | None = None) -> Optional[str]:
        if c := self._peek_char():
            if char is not None and c != char:
                return None
            self.pos += 1
            return c
        return None

    @memoize
    def _expects(self, string: str) -> Optional[str]:
        pos = self._mark()
        for c in string:
            if c != self._peek_char():
                self._reset(pos)
                return None
            self.pos += 1
        return string

    def _lookahead(self, positive, fn, *args):
        pos = self._mark()
        ok = fn(*args) is not None
        self._reset(pos)
        return ok == positive

    def _loop(self, nonempty, fn, *args):
        pos = self._mark()
        nodes = []
        while (node := fn(*args)) is not None:
            nodes.append(node)
        if len(nodes) >= nonempty:
            return nodes
        self._reset(pos)
        return None

    def _maybe(self, fn, *args):
        if (result := fn(*args)) is not None:
            return result
        return True

    def _get_char(self) -> str:
        char = self._peek_char()
        self.pos += 1
        return char

    def _peek_char(self) -> str:
        if self.pos == len(self.chars):
            self.chars.append(next(self.reader, None))
        return self.chars[self.pos]

    def _mark(self) -> int:
        return self.pos

    def _reset(self, pos: int):
        self.pos = pos

    class _LeftrecContextManager:
        def __init__(self, parser_instance, rules):
            self._parser_instance = parser_instance
            self._rules = rules

        def __enter__(self):
            p = self._parser_instance
            if p._leftrec is None:
                p._leftrec = Parser._LR(set(r.__name__ for r in self._rules))

        def __exit__(self, exc_type, exc_value, exc_tb):
            p = self._parser_instance
            p._leftrec = None

    def _setup_lr(self, *rules):
        return self._LeftrecContextManager(self, rules)

    def _action(self, rulename, *args, **kwargs):
        if self.actions is not None:
            fn = getattr(self.actions, rulename, None)
            if fn:
                return fn(**kwargs)
        return args

    def parse(self):
        return self._%% entry %%()

    %% body %%

if __name__ == '__main__':
    from argparse import ArgumentParser, FileType
    import sys

    argparser = ArgumentParser()
    argparser.add_argument('input_file', nargs='?',
                           type=FileType('r', encoding='UTF-8'),
                           default=sys.stdin)

    ns = argparser.parse_args()

    parser = Parser(ns.input_file)
    result = parser.parse()

    if result is not None:
        print(result)

    print("Parsing successful" if result else "Parsing failure")
    exit(not result)  # Unix-style: 0 is success
