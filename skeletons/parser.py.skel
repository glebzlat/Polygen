# This is automatically generated code, do not edit.
# Generated by Polygen %% version %%
# %% datetime %%


from __future__ import annotations

import io

from typing import Optional


def memoize(fn):
    def wrapper(self, *args):
        pos = self._mark()
        memo = self._memos.get(pos)
        if memo is None:
            memo = self._memos[pos] = {}
        key = (fn, args)
        if key in memo:
            res, endpos = memo[key]
            self._reset(endpos)
        else:
            res = fn(self, *args)
            endpos = self._mark()
            memo[key] = res, endpos
        return res

    return wrapper


class Reader:
    """
    Reads the file and produces a stream of characters.

    Reader supports strings and UTF-8 encoded streams only.
    """

    def __init__(self, stream: str | io.IOBase, bufsize=4096):
        self.buffer = ""
        self.stream = None
        self.name = None
        self.bufsize = bufsize
        self.eof = False
        self.pointer = 0
        self.line = 1
        self.column = 0

        if isinstance(stream, str):
            self.name = "<unicode string>"
        elif isinstance(stream, io.IOBase):
            self.name = getattr(stream, 'name', '<file>')
            self.stream = stream
            self.eof = False

            if not stream.readable():
                with_name = f": {self.name}" if self.name else ""
                raise ValueError("stream must be readable" + with_name)

    def __iter__(self) -> Reader:
        return self

    def __next__(self) -> str:
        try:
            char = self.buffer[self.pointer]
        except IndexError:
            if self.stream:
                self.update()
            try:
                char = self.buffer[self.pointer]
            except IndexError:
                self.eof = True
                raise StopIteration
        if char in '\r\n':
            self.line += 1
            self.column = 0
        else:
            self.column += 1
        self.pointer += 1
        return char

    def update(self, length: int = 1) -> None:
        assert self.stream
        if self.eof:
            return
        self.buffer = self.buffer[self.pointer:]
        self.pointer = 0
        while len(self.buffer) < length:
            data = self.stream.read(self.bufsize)
            if data:
                self.buffer += data
            else:
                self.eof = True
                break


class Parser:
    def __init__(self, stream):
        self._memos = {}
        self.reader = Reader(stream)
        self.chars: list[str] = []
        self.pos = 0

    @memoize
    def _expectc(self, char: str | None = None) -> Optional[str]:
        if c := self._peek_char():
            if char is not None and c != char:
                return None
            self.pos += 1
            return c
        return None

    @memoize
    def _expects(self, string: str) -> Optional[str]:
        pos = self._mark()
        for c in string:
            if c != self._peek_char():
                self._reset(pos)
                return None
            self.pos += 1
        return string

    def _lookahead(self, positive, fn, *args):
        pos = self._mark()
        ok = fn(*args) is not None
        self._reset(pos)
        return ok == positive

    def _loop(self, nonempty, fn, *args):
        pos = self._mark()
        nodes = []
        while (node := fn(*args)) is not None:
            nodes.append(node)
        if len(nodes) >= nonempty:
            return nodes
        self._reset(pos)
        return None

    def _maybe(self, fn, *args):
        if (result := fn(*args)) is not None:
            return result
        return True

    def _get_char(self) -> str:
        char = self._peek_char()
        self.pos += 1
        return char

    def _peek_char(self) -> str:
        if self.pos == len(self.chars):
            self.chars.append(next(self.reader, None))
        return self.chars[self.pos]

    def _mark(self) -> int:
        return self.pos

    def _reset(self, pos: int):
        self.pos = pos

    def parse(self):
        return self._%% entry %%()

    %% body %%

if __name__ == '__main__':
    from argparse import ArgumentParser, FileType
    import sys

    argparser = ArgumentParser()
    argparser.add_argument('input_file', type=FileType('r', encoding='UTF-8'),
                           default=sys.stdin)

    ns = argparser.parse_args()

    parser = Parser(ns.input_file)
    result = parser.parse()

    print("Parsing successful" if result else "Parsing failure")
    exit(not result)  # Unix-style: 0 is success
