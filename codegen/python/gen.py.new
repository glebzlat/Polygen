from io import TextIOBase

from polygen.utility import reindent

from polygen.gen_base import GeneratorBase
from polygen.node import GrammarVisitor

from polygen.node import (
    DLL,
    Grammar,
    Rule,
    Expr,
    Alt,
    NamedItem,
    Id,
    String,
    Char,
    AnyChar,
    Class,
    Range,
    ZeroOrOne,
    ZeroOrMore,
    OneOrMore,
    Repetition,
    And,
    Not
)


class Generator(GeneratorBase, GrammarVisitor):
    def __init__(self, grammar: Grammar, stream: TextIOBase, config):
        self.grammar = grammar
        self.config = config
        super().__init__(stream)

    def generate(self):
        self.visit(self.grammar)

    def visit_Grammar(self, node: Grammar):
        for i, r in enumerate(self.grammar):
            self.visit(r, i)

    def visit_Rule(self, node: Rule, index: int):
        if index:
            # Place empty line between rules, but not before the first rule
            self.emptyline()

        if node.leftrec:
            self.put(f"@_memoize_lr(head={bool(node.head)})")
        else:
            self.put("@_memoize")

        self.put(f"def _{node.id.value}(self):")

        with self.indent():

            if node.nullable:
                self.put("# Nullable")
            if node.leftrec:
                self.put(f"# Left recursive: {node.leftrec}")

            self.put("_begin_pos = self._mark()")
            self.visit(node.expr)
            self.put("return None")

    def visit_Expr(self, node: Expr):
        for i, alt in enumerate(node):
            self.visit(alt, i)

    def visit_Alt(self, node: Alt, index: int):
        variables = []

        length = DLL.length(node.items)
        if length == 0:
            self.put("if True:")

        elif length == 1:
            self.put("if (", newline=False)
            self.visit(node.items, 0, variables, newline=False)
            self.put("):", indent=False)

        else:
            self.put("if (")
            with self.indent():
                for i, item in enumerate(node):
                    self.visit(item, i, variables, newline=True)
            self.put("):")

        with self.indent():

            if node.nullable:
                self.put("# Nullable")

            # Unpack values from Success wrappers
            for var in variables:
                self.put(f"{var} = {var}.value")

            if node.metarule:
                self.emptyline()
                self.put(f"# Metarule: {node.metarule.id.value}")
                expr = reindent(node.metarule.expr, level=self.indent_level)
                self.put(expr.strip('\n'), indent=0)
            else:
                if len(variables) == 1:
                    self.put(f"return Success({variables[0]})")
                elif variables:
                    # Remove empty successes
                    return_value = ', '.join(variables)
                    self.put(f"__tup = tuple(x for x in ({return_value}) "
                             f"if x is not None")
                    self.put("return Success(__tup)")
                else:
                    self.put("return Success()")

            self.put("self._reset(_begin_pos)")

    def visit_NamedItem(self,
                        node: NamedItem,
                        index: int,
                        variables: list[str],
                        newline: bool):

        if node.name != NamedItem.IGNORE:
            self.put(f"{node.name} := ", newline=False, indent=newline)

        self.visit(node.item)

        if newline:
            self.put("", indent=False)

    def visit_ZeroOrOne(self, node: ZeroOrOne):
        with self.function_call("self._maybe"):
            self.visit(node.item)

    def visit_ZeroOrMore(self, node: ZeroOrMore):
        with self._function_call("self._loop"):
            self.put("False")
            self.visit(node.item)

    def visit_OneOrMore(self, node: OneOrMore):
        with self._function_call("self._loop"):
            self.put("True")
            self.visit(node.item)

    def visit_Repetition(self, node: Repetition):
        with self.function_call("self._rep"):
            self.put(node.beg)
            self.put(node.end)
            self.visit(node.item)

    def visit_And(self, node: And):
        with self.function_call("self._lookahead"):
            self.put("True")
            self.visit(node.item)

    def visit_Not(self, node: Not):
        with self.function_call("self._lookahead"):
            self.put("False")
            self.visit(node.item)

    def visit_String(self, node: String):
        with self.function_call("self._expects"):
            self.put(str(node))

    def visit_Char(self, node: Char):
        with self.function_call("self._expectc"):
            self.put(str(node))

    def visit_AnyChar(self, node: AnyChar):
        with self.function_call("self._expectc"):
            pass

    def visit_Id(self, node: Id):
        with self.function_call(f"self._{node.value}"):
            pass

    def visit_Class(self, node: Class):
        with self.function_call("self._ranges"):
            for r in node:
                self.visit(r)

    def visit_Range(self, node: Range) -> str:
        if node.last is None:
            self.put(str(node.first))
        else:
            self.put(f"({node.first}, {node.last})")
