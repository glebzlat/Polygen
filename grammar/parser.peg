@entry
Grammar     <- Spacing Entity+ EndOfFile                          $grammar_action
Entity      <- Definition / MetaDef
Definition  <- Directive* Identifier LEFTARROW Expression         $def_action
             / MetaDef

Directive   <- AT DirName Spacing                                 $directive_action
DirName     <- Identifier

Expression  <- Sequence seqs:(SLASH Sequence)*                    $expr_action
Sequence    <- parts:Prefix* m:MetaRule?                          $sequence_action
Prefix      <- MetaName? lookahead:(AND / NOT)? Suffix            $prefix_action
Suffix      <- Primary (QUESTION / STAR / PLUS / Repetition)?
Primary     <- Identifier !LEFTARROW
             / OPEN Expression CLOSE
             / Literal / Class / DOT
MetaName    <- Identifier SEMI                                    $metaname_action
MetaRule    <- '${' expr:(NestedBody / !'}' .)* '}' Spacing       $metarule_def_action
             / '$' Spacing Identifier !'{'                        $metarule_ref_action

MetaDef     <- '$' Spacing Identifier expr:MetaDefBody            $metadef_action
MetaDefBody <- '{' expr:(NestedBody / !'}' .)* '}' Spacing        $metadef_body_action
NestedBody  <- '{' body:(NestedBody / !'}' .)* '}'                $nested_body_action

Identifier  <- start:IdentStart cont:IdentCont* Spacing           $ident_action
IdentStart  <- [a-zA-Z_]
IdentCont   <- IdentStart / [0-9]

Literal     <- ['] chars:(!['] Char)* ['] Spacing                 $literal_action
             / ["] chars:(!["] Char)* ["] Spacing                 $literal_action
Class       <- '[' ranges:(!']' Range)* ']' Spacing               $class_action
Range       <- beg:Char '-' end:Char                              $range_2_action
             / beg:Char                                           $range_1_action
Char        <- '\\' char:[nrt'"\[\]\\]                            $esc_char_action
             / '\\' char1:[0-2] char2:[0-7] char3:[0-7]           $oct_char_action_1
             / '\\' char1:[0-7] char2:[0-7]?                      $oct_char_action_2
             / '\\u' chars:HexDigit{4}                            $unicode_char_action
             / !'\\' any:.                                        $any_char_action

Repetition  <- '{'
               grp:(Number _:',' Number / Number) '}' Spacing     $rep_action
Number      <- chars:[0-9]+                                       $number_action
HexDigit    <- char:[a-fA-F0-9]

@ignore
LEFTARROW   <- '<-' Spacing
@ignore
SLASH       <- '/' Spacing
AND         <- '&' Spacing  $and_action
NOT         <- '!' Spacing  $not_action
QUESTION    <- '?' Spacing  $optional_action
STAR        <- '*' Spacing  $zero_or_more_action
PLUS        <- '+' Spacing  $one_or_more_action
@ignore
OPEN        <- '(' Spacing
@ignore
CLOSE       <- ')' Spacing
DOT         <- '.' Spacing  $dot_action
@ignore
AT          <- '@' Spacing
@ignore
SEMI        <- ':' Spacing

@ignore
Spacing     <- (Space / Comment)*
Comment     <- '#' (!EndOfLine .)* EndOfLine
Space       <- ' ' / '\t' / EndOfLine
EndOfLine   <- '\r\n' / '\n' / '\r'
EndOfFile   <- !.

$grammar_action {
  return Grammar(*entity, begin_pos=_begin_pos)
}

$def_action {
  return Rule(identifier, expression, directives=directive,
              begin_pos=_begin_pos)
}

$directive_action {
  return dirname.string
}

$expr_action {
  return Expression(sequence, *seqs, begin_pos=_begin_pos)
}

$sequence_action {
  m = m if isnode(m) else None
  return Alt(*parts, metarule=m, begin_pos=_begin_pos)
}

$prefix_action {
  metaname = metaname if isinstance(metaname, str) else None
  lookahead = lookahead if isnode(lookahead) else None
  prime, *rest = suffix
  quant = rest[0] if rest else None
  return Part(lookahead=lookahead, prime=prime, quant=quant, metaname=metaname,
              begin_pos=_begin_pos)
}

$metaname_action {
  return identifier.string
}

$metarule_def_action {
  string = ''.join(expr)
  return MetaRule(expr=string, begin_pos=_begin_pos)
}

$metarule_ref_action {
  return MetaRef(identifier, begin_pos=_begin_pos)
}

$metadef_action {
  return MetaRule(id=identifier, expr=expr,
                  begin_pos=_begin_pos)
}

$metadef_body_action {
  return ''.join(expr)
}

$nested_body_action {
  string = ''.join(body)
  return f"{{{string}}}"
}

$ident_action {
  string = ''.join((start, *cont))
  return Identifier(string, begin_pos=_begin_pos)
}

$literal_action {
  if len(chars) == 1:
    return chars[0]
  return String(*chars, begin_pos=_begin_pos)
}

$class_action {
  return Class(*ranges, begin_pos=_begin_pos)
}

$range_2_action {
  return Range(beg, end, begin_pos=_begin_pos)
}

$range_1_action {
  return Range(beg, begin_pos=_begin_pos)
}

$esc_char_action {
  CHR_MAP = {
      'n': Char('\n'),
      'r': Char('\r'),
      't': Char('\t'),
      '\'': Char('\''),
      '\"': Char('\"'),
      '[': Char('['),
      ']': Char(']'),
      '\\': Char('\\')
  }

  node = CHR_MAP[char]
  node.begin_pos = _begin_pos
  node.end_pos = self._mark()
  return node
}

$oct_char_action_1 {
  string = ''.join((char1, char2, char3))
  return Char(int(string, base=8), begin_pos=_begin_pos)
}

$oct_char_action_2 {
  char2 = char2 if isinstance(char2, str) else ''
  string = ''.join((char1, char2))
  return Char(int(string, base=8), begin_pos=_begin_pos)
}

$unicode_char_action {
  string = ''.join(chars)
  return Char(int(string, base=16), begin_pos=_begin_pos)
}

$any_char_action {
  return Char(ord(any), begin_pos=_begin_pos)
}

$rep_action {
  beg, end = grp if isinstance(grp, tuple) else (grp, None)
  return Repetition(beg, end, begin_pos=_begin_pos)
}

$number_action {
  string = ''.join(chars)
  return int(string)
}

$and_action {
  return And(begin_pos=_begin_pos)
}

$not_action {
  return Not(begin_pos=_begin_pos)
}

$optional_action {
  return ZeroOrOne(begin_pos=_begin_pos)
}

$zero_or_more_action {
  return ZeroOrMore(begin_pos=_begin_pos)
}

$one_or_more_action {
  return OneOrMore(begin_pos=_begin_pos)
}

$dot_action {
  return AnyChar(begin_pos=_begin_pos)
}
