# Additions

Well, what will happen, if I make all the nodes just dictionaries? And test
parsers using files: file with the input grammar and file with resulting
nodes in json?

Replace True value in the generated parser by an empty tuple (). This will
make resulting raw tree more consistent.

Bugs:
    test_generated_parsers:
        TestNestedQuantifiers
        TestChars
            unicode char parsing
        TestIgnoreRuleUnignored
        TestHiddenLeftRecursion_Simple
        TestHiddenLeftRecursion_Complicated
        TestIndirectLeftRecursion_TwoBranches
            if the rule has two recursive paths, and parsing started
            from the first branch, then the second branch will never be
            parsed.
        TestInterlockingLeftRecursion

Write tests

    - [x] Reader
    - [x] Parser
    - [ ] Nodes
    - [ ] Tree modifier
        - [x] ExpandClass
        - [x] ReplaceRep
        - [ ] ReplaceZeroOrOne -- is it needed at all?
        - [ ] ReplaceOneOrMore -- the same
        - [x] CheckUndefRedef
        - [x] SimplifyNestedExps
        - [x] ReplaceNestedExps
        - [x] CreateAnyCharRule
        - [x] FindEntryRule
        - [x] IgnoreRules
        - [x] GenerateMetanames
        - [x] SubstituteMetaRefs
        - [ ] DetectLeftRec
    - [x] Preprocessor
    - [x] Generated parsers
        - [x] Left recursion

Implement features

    - [ ] Left recursion.
          See "Packrat parsers can support left recursion" A. Warth, J.R.
          Douglass, T. Millstein.
    - [ ] Cuts.
          See "Packrat parsers can handle practical grammars in mostly
          constant space" K. Mizushima, A. Maeda, Y. Yamaguchi.
    - [ ] Enhanced skeleton file preprocessor.
          Add preprocessing language with conditional expressions
    - [ ] Backend capabilities registry.
          Each backend must define what node types it can accept and what
          features it implements (like left recursion).
    - [ ] Grammar preprocessor.
          @include directive, group directives.
    - [ ] Parser: return a tuple (success, value), not just single value.
          If some function returns (True, None) then filter out None from
          the resulting tree.
