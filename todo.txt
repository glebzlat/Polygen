# Additions

Add new node type: MetaRule. MetaRules are pieces of code, which will be
inserted by the parser generator into the parsing functions. Metarules may
be unnamed (when occured right after the Rule in the curly braces preceded by
the dollar sign [1]) and named. Named rules are occured as standalone
entities, which consist of the dollar sign, identifier and the code in the
curly braces [2].
    1. Rule <- Expr ${ ... }
    2. $identifier { ... }
If the rule is named, it may be referenced. In this case, the reference is
placed after the rule:
    Rule <- Expr $identifier
So the type of metarule attribute of the Rule class is MetaRule | Identifier.

Add new parsing rule _Entity
    _Entity <- Definition / MetaDef
Definition yields Rule, MetaDef yields MetaRule.

Metarules are the part of the grammar, they may appear in the same place,
as the general rules. Later, they must be eliminated by the tree modifier:
metarule references will be replaced by the metarule definitions; unnamed
metarule definitions will be assigned to Rule's metarule attributes.

Note that metarules should be replaced in the grammar in-place, which may
be a headache because of iterator's immutability.

Add grammar preprocessor. Grammar preprocessor will extend directive language.
It will make possible to write
    @ignore {
    Rule1 <- ...
    ...
    RuleN <- ...
    }
which will be substituted by:
    @ignore
    Rule1 <- ...
    ...
    @ignore
    RuleN <- ...
which itself will be parsed by the grammar parser.

Add grammar preprocessor @include directive.

How to add semantic actions? Or just generate a parsing tree and that's enough?

Add TreeModifier tests.

Add the whole grammar tests - compare generated AST with the saved.

Add modified AST tests - compare modified AST with the saved.

Add start, end indexes to generated nodes.

Develop a config protocol.

Add generated parser tests. Parser without semantic actions should return
True, if the grammar is parsed and False otherwise. This test should generate
a temporary parser, evaluate it and test it against test grammar files.

# Proposals

Apply another mechanism of node filtering for semantic rules. Instead of
keeping a `node_type` variable, which may be a single type or a sequence
of types, define methods with the name `visit_*`, where `*` designates
node's type name. Like so: `visit_Expression`.

Allow post-visit actions.

Add the config. Which format to use?

Add parser syntastic error reporting (use "Exception Handling for Error
Reporting in Parsing Expression Grammars" research paper).

Add the parser generator. All the project should be split into parts:
- Front-end -- parser, creates the tree, checks for syntax errors,
- Middleware -- converter, applies rules to the tree, checks for semantic
  errors, and
- Back-end -- parser generator.

Front-end does not and should not know about the semantic rules, applied by
the Middleware -- its responsibility is to generate the AST.

Middleware, I think, will consist mainly of RuleRewriter.

Back-end must implement a set of basic features (ordered choice, zero-or-more,
not predicate, etc.) and it may implement additional features (like one-or-more,
and predicate, etc.). In case if it implements additional features, it may
instruct the Middleware to not eliminate them from the tree.

Back-end may be implemented in _any_ language (at the cost of writing and
debugging time, of course). That is, the tree should have an ability to be
represented in some fancy and easy parseable way (e.g., it should be
convertible to JSON). For the same reason, configs and other ways for the
system parts (and the end-user) to interact should be convertible to another
parseable (and human-readable) format.

BTW, user should have an ability to write his own Middleware rules and attach
them, even if he writes them in another language.

Add semantic actions. How?

Semantic actions and the grammar should be distinct. No curly braces with
pieces of code in the grammar file -- semantic actions in generated parsers
should be attached at the end -- this is responsibility of the Back-end.
