# Ordered choice: A = E1 / E2 / ... / En
def A():
    pos = _mark()
    if self.E1():
        return True
    if self.E2():
        return True
    ...
    if self.En():
        return True
    _reset(pos)
    return False


# Sequence: A = E1 E2 ... En
def A():
    pos = _mark()
    if not E1():
        _reset(pos)
        return False
    if not E2():
        _reset(pos)
        return False
    ...
    if not En():
        _reset(pos)
        return False
    return True


# And predicate: A = &E
def A():
    pos = _mark()
    if not E():
        return False
    _reset(pos)
    return True


# Not predicate: A = !E
def A():
    pos = _mark()
    if not E():
        return True
    _reset(pos)
    return False


# One or more: A = E+
def A():
    if not E():
        return False
    while E():
        pass
    return True


# Zero or more: A = E*
def A():
    while E():
        pass
    return True


# Zero or one: A = E?
def A():
    E()
    return True


# Character class: A = [n]
def A():
    pos = _mark()
    if buffer[pos] != n:
        return False
    _advance(1)
    return True


# Character range: A = [n-m]
def A():
    pos = _mark()
    if buffer[pos] not in range(n, m + 1):
        return False
    _advance(1)
    return True


# String: A = "s"
def A():
    pos = _mark()
    for c in string:
        if buffer[pos] != c:
            return False
        pos += 1
    advance(len(string))
    return True


# Char: A = 'c'
def A():
    pos = _mark()
    if buffer[pos] == c:
        _advance(1)
        return True
    return False


# Any character: A = .
def A():
    if not _eof():
        _advance(1)
        return True
    return False
